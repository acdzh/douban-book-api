const data = {
  title: 'Haskell趣学指南',
  subtitle: '',
  original_title: 'Learn You a Haskell for Great Good!',
  id: '25803388',
  isbn: '9787115335593',
  author: [
    '[斯洛文尼亚] Miran Lipovaca'
  ],
  translator: [
    '李亚舟',
    '宋方睿'
  ],
  publish: '人民邮电出版社',
  producer: '',
  publishDate: '2014-1',
  pages: '301',
  price: '',
  binging: '平装',
  series: '新锐编程语言集萃',
  book_intro: '《haskell趣学指南》是一本讲解haskell这门函数式编程语言的入门指南，语言通俗易懂，插图生动幽默，示例短小清晰，结构安排合理。书中从haskell的基础知识讲起，涵盖了所有的基本概念和语法，内容涉及基本语法、递归、类型和类型类、函子、applicative 函子、monad、zipper及所有haskell重要特性和强大功能。\n《haskell趣学指南》适合对函数式编程及haskell语言感兴趣的开发人员阅读。',
  author_intro: 'Miran Lipovaca 斯洛文尼亚共和国卢布尔雅那城的一位计算机科学专业的学生。除了对Haskell的狂热，他还喜欢拳击，玩低音吉他，当然还有画画。\n译者介绍\n李亚舟 毕业于山东理工大学，现就职于IBM LTC，从事Linux发行版相关工作。对内核、体系结构、编程语言及技术翻译有浓厚兴趣，敬仰那些孜孜不倦地精益求精的人们。\n宋方睿 本科生，清华大学开源镜像站维护者，blue-lotus战队成员，热爱算法和程序设计语言理论，关注高性能计算、自然语言处理及前端技术。个人博客http://maskray.me。',
  catalog: [
    '《haskell趣学指南》',
    '第1章　各就各位，预备！　1',
    '1.1　调用函数　3',
    '1.2　小朋友的第一个函数　4',
    '1.3　列表入门　6',
    '1.3.1　拼接列表　6',
    '1.3.2　访问列表中的元素　8',
    '1.3.3　嵌套列表　8',
    '1.3.4　比较列表　8',
    '1.3.5　更多列表操作　9',
    '1.4　得州区间　11',
    '1.5　我是列表推导式　13',
    '1.6　元组　16',
    '1.6.1　使用元组　16',
    '1.6.2　使用序对　17',
    '1.6.3　找直角三角形　18',
    '第2章　相信类型　20',
    '2.1　显式类型声明　20',
    '2.2　haskell的常见类型　21',
    '2.3　类型变量　22',
    '.2.4　类型类入门　23',
    '2.4.1　eq类型类　24',
    '2.4.2　ord类型类　24',
    '2.4.3　show类型类　25',
    '2.4.4　read类型类　25',
    '2.4.5　enum类型类　27',
    '2.4.6　bounded类型类　27',
    '2.4.7　num类型类　28',
    '2.4.8　floating类型类　28',
    '2.4.9　integeral类型类　28',
    '2.4.10　有关类型类的最后总结　29',
    '第3章　函数的语法　30',
    '3.1　模式匹配　30',
    '3.1.1　元组的模式匹配　32',
    '3.1.2　列表与列表推导式的模式匹配　32',
    '3.1.3　as模式　34',
    '3.2　注意，哨卫!　34',
    '3.3　where？！　36',
    '3.3.1　where的作用域　37',
    '3.3.2　where中的模式匹配　38',
    '3.3.3　where块中的函数　38',
    '3.4　let　39',
    '3.4.1　列表推导式中的let　40',
    '3.4.2　ghci中的let　40',
    '3.5　case表达式　41',
    '第4章　你好，递归　43',
    '4.1　不可思议的最大值　43',
    '4.2　更多的几个递归函数　45',
    '4.2.1　replicate　45',
    '4.2.2　take　45',
    '4.2.3　reverse　46',
    '4.2.4　repeat　46',
    '4.2.5　zip　46',
    '4.2.6　elem　47',
    '4.3　快点，排序！　47',
    '4.3.1　算法思路　47',
    '4.3.2　编写代码　48',
    '4.4　递归地思考　49',
    '第5章　高阶函数　50',
    '5.1　柯里函数　50',
    '5.1.1　截断　52',
    '5.1.2　打印函数　53',
    '5.2　再来点儿高阶函数　53',
    '5.2.1　实现zipwith　54',
    '5.2.2　实现flip　55',
    '5.3　函数式程序员工具箱　56',
    '5.3.1　map函数　56',
    '5.3.2　filter函数　57',
    '5.3.3　有关map与filter的更多示例　58',
    '5.3.4　映射带有多个参数的函数　60',
    '5.4　lambda　60',
    '5.5　折叠纸鹤　62',
    '5.5.1　通过foldl进行左折叠　63',
    '5.5.2　通过foldr进行右折叠　63',
    '5.5.3　foldl1函数与foldr1函数　64',
    '5.5.4　折叠的几个例子　65',
    '5.5.5　另一个角度看折叠　66',
    '5.5.6　无限列表的折叠　67',
    '5.5.7　扫描　68',
    '5.6　有$的函数应用　68',
    '5.7　函数组合　70',
    '5.7.1　带有多个参数函数的组合　70',
    '5.7.2　point-free风格　71',
    '第6章　模块　73',
    '6.1　导入模块　73',
    '6.2　使用模块中的函数求解问题　75',
    '6.2.1　统计单词数　75',
    '6.2.2　干草堆中的缝纫针　76',
    '6.2.3　凯撒密码沙拉　77',
    '6.2.4　严格左折叠　79',
    '6.2.5　寻找酷数　80',
    '6.3　映射键与值　82',
    '6.3.1　几乎一样好：关联列表　82',
    '6.3.2　进入data.map　83',
    '6.4　构造自己的模块　87',
    '6.4.1　几何模块　87',
    '6.4.2　模块的层次结构　89',
    '第7章　构造我们自己的类型和类型类　91',
    '7.1　定义新的数据类型　91',
    '7.2　成型　92',
    '7.2.1　借助point数据类型优化shape数据类型　93',
    '7.2.2　将图形导出到模块中　94',
    '7.3　记录语法　95',
    '7.4　类型参数　97',
    '7.4.1　要不要参数化我们的汽车？　99',
    '7.4.2　末日向量　100',
    '7.5　派生实例　102',
    '7.5.1　相同的人　102',
    '7.5.2　告诉我怎么读　103',
    '7.5.3　法庭内保持秩序！　104',
    '7.5.4　一周的一天　105',
    '7.6　类型别名　106',
    '7.6.1　使我们的电话本更好看些　107',
    '7.6.2　参数化类型别名　108',
    '7.6.3　向左走，向右走　109',
    '7.7　递归数据结构　111',
    '7.7.1　优化我们的列表　111',
    '7.7.2　种一棵树　113',
    '7.8　类型类　115',
    '7.8.1　深入eq类型类　116',
    '7.8.2　trafficlight数据类型　116',
    '7.8.3　子类化　118',
    '7.8.4　作为类型类实例的带参数类型　118',
    '7.9　yes-no类型类　120',
    '7.10　functor类型类　122',
    '7.10.1　maybe函子　124',
    '7.10.2　树也是函子　124',
    '7.10.3　either a函子　125',
    '7.11　kind与无名类型　126',
    '第8章　输入与输出　128',
    '8.1　纯粹与非纯粹的分离　128',
    '8.2　hello, world！　129',
    '8.3　组合i/o操作　130',
    '8.3.1　在i/o操作中使用let　132',
    '8.3.2　反过来　133',
    '8.4　几个实用的i/o函数　135',
    '8.4.1　putstr　135',
    '8.4.2　putchar　135',
    '8.4.3　print　136',
    '8.4.4　when　137',
    '8.4.5　sequence　137',
    '8.4.6　mapm　138',
    '8.4.7　forever　139',
    '8.4.8　form　139',
    '8.5　i/o操作回顾　140',
    '第9章　更多的输入输出操作　141',
    '9.1　文件和流　141',
    '9.1.1　输入重定向　141',
    '9.1.2　从输入流获取字符串　142',
    '9.1.3　转换输入　144',
    '9.2　读写文件　146',
    '9.2.1　使用withfile函数　147',
    '9.2.2　bracket的时间到了　148',
    '9.2.3　抓住句柄　149',
    '9.3　todo列表　149',
    '9.3.1　删除条目　150',
    '9.3.2　清理　152',
    '9.4　命令行参数　153',
    '9.5　关于todo列表的更多有趣的事　154',
    '9.5.1　一个多任务列表　155',
    '9.5.2　处理错误的输入　158',
    '9.6　随机性　159',
    '9.6.1　掷硬币　160',
    '9.6.2　更多随机函数　161',
    '9.6.3　随机性和i/o　162',
    '9.7　字节串　165',
    '9.7.1　严格的和惰性字节串　166',
    '9.7.2　用字节串复制文件　167',
    '第10章　函数式地解决问题　169',
    '10.1　逆波兰式计算器　169',
    '10.1.1　计算rpn表达式　169',
    '10.1.2　写一个rpn函数　170',
    '10.1.3　添加更多的操作符　172',
    '10.2　从希思罗机场到伦敦　173',
    '10.2.1　计算最快的路线　174',
    '10.2.2　在haskell中表示道路系统　176',
    '10.2.3　实现计算最佳路径的函数　177',
    '10.2.4　从输入获取道路系统　179',
    '第11章　applicative函子　182',
    '11.1　函子再现　182',
    '11.1.1　作为函子的i/o操作　183',
    '11.1.2　作为函子的函数　185',
    '11.2　函子定律　187',
    '11.2.1　定律1　188',
    '11.2.2　定律2　188',
    '11.2.3　违反定律　189',
    '11.3　使用applicative函子　191',
    '11.3.1　向applicative问好　192',
    '11.3.2　maybe applicative函子　192',
    '11.3.3　applicative风格　193',
    '11.3.4　列表　195',
    '11.3.5　io也是applicative函子　197',
    '11.3.6　函数作为applicative　198',
    '11.3.7　zip列表　199',
    '11.3.8　applicative定律　200',
    '11.4　applicative的实用函数　201',
    '第12章　monoid　205',
    '12.1　把现有类型包裹成新类型　205',
    '12.1.1　用newtype创建类型类的实例　207',
    '12.1.2　关于newtype的惰性　208',
    '12.1.3　type、newtype和data三者的对比　210',
    '12.2　关于那些monoid　211',
    '12.2.1　monoid类型类　212',
    '12.2.2　monoid定律　213',
    '12.3　认识一些monoid　213',
    '12.3.1　列表是monoid　213',
    '12.3.2　product和sum　214',
    '12.3.3　any和all　216',
    '12.3.4　ordering monoid　217',
    '12.3.5　maybe monoid　219',
    '12.4　monoid的折叠　221',
    '第13章　更多monad的例子　224',
    '13.1　升级我们的applicative函子　224',
    '13.2　体会maybe　225',
    '13.3　monad类型类　228',
    '13.4　一往无前　229',
    '13.4.1　代码，代码，代码　230',
    '13.4.2　我要飞走　231',
    '13.4.3　线上的香蕉　234',
    '13.5　do记法　235',
    '13.5.1　按我所说的去做　236',
    '13.5.2　我皮埃尔又回来了　237',
    '13.5.3　模式匹配和计算失败　238',
    '13.6　列表monad　239',
    '13.6.1　do记法和列表推导式　241',
    '13.6.2　monadplus和guard函数　242',
    '13.6.3　马的探索　243',
    '13.7　monad定律　245',
    '13.7.1　左单位元　246',
    '13.7.2　右单位元　246',
    '13.7.3　结合律　247',
    '第14章　再多一些monad　249',
    '14.1　writer？我没听说过啊！　249',
    '14.1.1　monad赶来营救　251',
    '14.1.2　writer类型　253',
    '14.1.3　对writer使用do记法　254',
    '14.1.4　给程序添加日志　255',
    '14.1.5　低效的列表构造　257',
    '14.1.6　使用差分列表　258',
    '14.1.7　比较性能　259',
    '14.2　reader？呃，不开玩笑了　260',
    '14.2.1　作为monad的函数　261',
    '14.2.2　reader monad　261',
    '14.3　带状态计算的优雅表示　262',
    '14.3.1　带状态的计算　263',
    '14.3.2　栈和石头　264',
    '14.3.3　state monad　265',
    '14.3.4　获取和设置状态　267',
    '14.3.5　随机性和state monad　268',
    '14.4　墙上的error　269',
    '14.5　一些实用的monad式的函数　271',
    '14.5.1　liftm和它的朋友们　271',
    '14.5.2　join函数　274',
    '14.5.3　filterm　276',
    '14.5.4　foldm　278',
    '14.6　创建一个安全的rpn计算器　279',
    '14.7　组合monad式的函数　281',
    '14.8　创建monad　282',
    '第15章　zipper　287',
    '15.1　在树上移动　287',
    '15.1.1　面包屑　290',
    '15.1.2　向上走　291',
    '15.1.3　处理焦点处的树　293',
    '15.1.4　一路走到顶端，那里的空气既新鲜又干净　294',
    '15.2　在列表上定位　294',
    '15.3　一个非常简单的文件系统　295',
    '15.3.1　为文件系统创建一个zipper　296',
    '15.3.2　操作文件系统　298',
    '15.4　小心行事　299',
    '15.5　谢谢阅读！　301'
  ],
  original_texts: [],
  labels: [],
  cover_url: 'https://img9.doubanio.com/view/subject/l/public/s27195536.jpg',
  url: 'https://book.douban.com/subject/25803388/',
  rating: {
    count: 274,
    info: '',
    value: 8.9,
    five_star_pre: 51.1,
    four_star_pre: 42.3,
    three_star_pre: 5.1,
    two_star_pre: 1.1,
    one_star_pre: 0.4
  },
  comments: [],
  reviews: [],
  notes: []
};

module.exports = data;